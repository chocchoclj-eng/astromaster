// app/api/chart/route.ts
import { NextResponse } from "next/server";
import { saveChart } from "@/lib/chartStore";
import { computeAspects } from "@/lib/aspectEngine";

// ✅ 重要：确保 Next.js 用 node runtime，才能写文件
export const runtime = "nodejs";

// 你原来这里应该已经 import 了 astrology-engine 相关逻辑
// 我保持你的结构：最终你会得到 keyConfig（你现有代码已经算出来了）

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const { name, birthDateTime, utcOffset, city, lat, lon } = body;

    // ---------------------------
    // 这里保持你现有的“星盘计算逻辑”
    // 最终得到 keyConfig（你现在的 route.ts 已经能算出来）
    // ---------------------------

    // ====== 下面这段用你现有 route.ts 的 keyConfig 生成结果替换 ======
    // 为了让你直接用：我用 “any keyConfig” 占位，你把你现有的 keyConfig 继续保留
    const keyConfig: any = (globalThis as any).__keyConfig_placeholder;

    // ✅ 你现有代码最后 return NextResponse.json({ keyConfig, id: crypto.randomUUID() });
    // 我这里接着做：整理 coreFull + aspectsFull + 落库

    // ---------------------------
    // 1) 组装 coreFull（全量行星落点）
    // 你现有 keyConfig 里至少有 input/core/nodes/debug/…等
    // 我这里尽最大可能“兼容”你现有结构：
    // - 如果你已经有 planets/houses，就直接用
    // - 如果没有，就从你现有 placement(...) 或 debug lon 推导不了时也不报错
    // ---------------------------
    const coreFull = keyConfig.coreFull ?? {};

    // 如果你还没有 coreFull.planets，这里从你已有的 placements 尝试拼一份
    // 你可以按自己项目里实际的“行星经度计算变量”进一步补全
    if (!coreFull.planets) {
      const maybe = [
        keyConfig?.core?.sun ? { body: "Sun", ...keyConfig.core.sun } : null,
        keyConfig?.core?.moon ? { body: "Moon", ...keyConfig.core.moon } : null,
        keyConfig?.core?.asc ? { body: "ASC", ...keyConfig.core.asc } : null,
        keyConfig?.core?.mc ? { body: "MC", ...keyConfig.core.mc } : null,
        // 你 route.ts 里有 saturn
        keyConfig?.core?.saturn ? { body: "Saturn", ...keyConfig.core.saturn } : null,
      ].filter(Boolean);

      coreFull.planets = maybe;
    }

    // 2) 计算 aspectsFull（全量相位）
    // 需要每个 body 有 lon（黄经）
    const aspectBodies = (coreFull.planets ?? [])
      .map((p: any) => ({ body: p.body, lon: Number(p.lon) }))
      .filter((x: any) => Number.isFinite(x.lon));

    const aspectsFull = computeAspects(aspectBodies);

    keyConfig.coreFull = {
      ...coreFull,
      aspectsFull,
    };

    // 3) 生成稳定 id（你也可以换成 birthDateTimeUTC，但你现在已有 randomUUID）
    const id = crypto.randomUUID();

    // 4) 落库（文件存储）
    await saveChart({
      id,
      createdAt: new Date().toISOString(),
      keyConfig,
    });

    return NextResponse.json({ id, keyConfig });
  } catch (e: any) {
    console.error("CHART API ERROR:", e);
    return NextResponse.json({ error: e?.message || "chart api failed" }, { status: 500 });
  }
}
